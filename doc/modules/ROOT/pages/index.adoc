// ===========================================================================
//                         Copyright 2001 Jeremy Siek
//                Copyright 2003-2004, 2008, 2025 Gennaro Prota
//                        Copyright 2014 Ahmed Charles
//                     Copyright 2014 Riccardo Marcangelo
//                        Copyright 2018 Evgeny Shulgin
//
//         Distributed under the Boost Software License, Version 1.0.
//              (See accompanying file LICENSE_1_0.txt or copy at
//                    http://www.boost.org/LICENSE_1_0.txt)
// ===========================================================================

= Boost.DynamicBitset

Boost.DynamicBitset is a portable library that provides a set of bits.

The set (`boost::dynamic_bitset`) provides access to the value of individual
bits via `operator[]` and provides all of the bitwise operators that one can
apply to builtin integers, such as `operator&` and `operator<<`. The number of
bits can change at runtime.

`dynamic_bitset` is nearly identical to `std::bitset`. The difference is that
the size of a `dynamic_bitset` (the number of bits) can change at runtime,
whereas the size of a `std::bitset` is specified at compile-time through an
integer template parameter.

The main problem that `dynamic_bitset` is designed to solve is that of
representing a subset of a finite set. Each bit represents whether an element of
the finite set is in the subset or not. As such the bitwise operations of
`dynamic_bitset`, such as `operator&` and `operator|`, correspond to set
operations, such as intersection and union.

== Definitions
Each bit represents either the Boolean value `true` or `false` (1 or 0). To set
a bit is to assign it 1. To clear or reset a bit is to assign it 0. To flip a
bit is to change the value to 1 if it was 0 and to 0 if it was 1. Each bit has a
non-negative position. A bitset `x` contains `x.size()` bits, with each bit
assigned a unique position in the range `[0, x.size())`. The bit at position 0
is called the least significant bit and the bit at position `size() - 1` is the
most significant bit. When converting an instance of `dynamic_bitset` to or from
an unsigned long `n`, the bit at position `i` of the bitset has the same value
as `(n >> i) & 1`.

== Rationale
`dynamic_bitset` is not a <a
href="https://en.cppreference.com/w/cpp/named_req/Container.html">Container</a>
and does not provide iterators for the following reason:

A container with a proxy reference type can not fulfill the container
requirements as specified in the C++ standard (unless one resorts to strange
iterator semantics). `std::vector<bool>` has a proxy reference type and does not
fulfill the container requirements and as a result has caused many problems. One
common problem is when people try to use iterators from `std::vector<bool>` with
a standard algorithm such as `std::search()`. The `std::search()` requirements
say that the iterator must be a LegacyForwardIterator, but
`std::vector<bool>::iterator` does not meet this requirement because of the
proxy reference. Depending on the implementation, they may or not be a compile
error or even a run-time error due to this misuse. For further discussion of the
problem see "Effective STL" by Scott Meyers. So `dynamic_bitset` tries to avoid
these problems by not pretending to be a container.

Some people prefer the name "toggle" to "flip". The name "flip" was chosen
because that is the name used in `std::bitset`. In fact, most of the function
names for `dynamic_bitset` were chosen for this reason.

`dynamic_bitset` does not throw exceptions when a precondition is violated (as
is done in `std::bitset`). Instead `BOOST_ASSERT()` is used. See the guidelines
for Error and Exception Handling for the explanation. Note that, consistently
with this, the documentation of the member functions doesn't use the term
"precondition" for conditions that cause an exception to be emitted (the C++
standard uses the term "requires" in such cases).

== Acknowledgments

We would like to thank the Boost community for putting in the time to review and
accept this library. This library is much better than it ever would have been
due to all the suggestions from Boost members. We especially thank Matt Marcus
for taking on the task of review manager. Also, a special thanks goes to James
Kanze for his invaluable help with the internationalization issues.
